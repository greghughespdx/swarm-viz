![swarm-viz for Overstory](docs/images/header.png)

Written (appropriately) in TypeScript, swarm-viz is a real-time WebGL visualization of an [Overstory](https://github.com/jayminwest/overstory) multi-agent swarm. Art meets tech: Watch agents spawn, message each other, and merge work, live, at 60fps. 

Overstory was created by Jaymin West, and you really should check/try it out. Get a little crazy, burn some tokens, learn a Lot.

---

## What It Shows

You run an agent swarm on Overstory, and the swarm-viz service lights up your browser.

| Visual | What It Represents |
|--------|--------------------|
| Glowing orbs | Active agents, colored by capability |
| Pulsing | Agent is working; pulse rate reflects activity |
| Spawn bloom | New agent entering the swarm |
| Fade-out | Agent completing and exiting |
| Arc trails | Messages flying between agents |
| Diamonds | Entries in the merge queue |
| HUD overlay | Live counts: agents, messages, estimated cost |

Agent capabilities have distinct colors: coordinator, lead, scout, builder, reviewer, merger.

---

## Architecture

```
Overstory SQLite DBs ──→ Bun WebSocket server ──→ Browser (Three.js canvas)
 sessions.db              server/index.ts           client/main.ts
 mail.db                  (polls every 500ms)        client/scene.ts
 merge-queue.db           port 33020                 Full-screen WebGL
 metrics.db (optional)
```

The server reads Overstory state databases in **read-only** mode and pushes incremental updates over WebSocket. The browser renders a live force-directed graph using Three.js with UnrealBloom post-processing.

---

## Quick Start

**Prerequisites:** [Bun](https://bun.sh) runtime.

```bash
# Install dependencies
bun install

# Demo mode (no Overstory install needed, simulated swarm data)
bun run demo

# Live mode (reads .overstory/ databases from a real swarm)
bun run dev

# Point at a specific Overstory install
OVERSTORY_DIR=/path/to/project/.overstory bun run dev

# Production build, then serve
bun run build
bun run dev
```

Open `http://localhost:33020` in your browser (port set via `.env`).

Demo mode generates synthetic agent activity so you can see the visualization without running a live swarm.

---

## Configuration

All configuration is via environment variables:

| Variable | Default | Description |
|----------|---------|-------------|
| `OVERSTORY_DIR` | `./.overstory` | Path to the Overstory state directory |
| `PORT` | `3000` | HTTP/WebSocket server port (set to `33020` in `.env`) |
| `POLL_INTERVAL_MS` | `500` | How often the server polls SQLite for changes (ms) |
| `STATIC_DIR` | `./dist` | Directory to serve the built client from |
| `DEMO_MODE` | `false` | Set to `true` for simulated swarm data (no databases needed) |

### npm Scripts

| Command | What it does |
|---------|-------------|
| `bun run dev` | Start the server in live mode (reads Overstory databases) |
| `bun run demo` | Start the server in demo mode (simulated data) |
| `bun run build` | Bundle the client into `dist/` for production |
| `bun run typecheck` | TypeScript type check (no emit) |
| `bun run lint` | Biome lint + format check on `client/` |
| `bun test` | Run tests |

### Endpoints

| Path | Description |
|------|-------------|
| `/` | WebGL visualization (serves `dist/index.html`) |
| `/ws` | WebSocket endpoint for real-time state updates |
| `/health` | Health check (returns JSON with database status) |

---

## Data Sources

The server reads four SQLite databases from `OVERSTORY_DIR`:

| Database | Required | Contents |
|----------|----------|----------|
| `sessions.db` | Yes | Agent sessions — name, state, depth, parent, activity |
| `mail.db` | Yes | Inter-agent messages — from, to, type, priority, timestamp |
| `merge-queue.db` | Yes | Branch merge queue — status, files modified |
| `metrics.db` | No | Token usage and cost per session |

If `metrics.db` is absent the visualization runs normally; cost metrics show as zero.

All reads use `readonly: true` — swarm-viz never writes to Overstory state.

---

## Build

```bash
bun run build
```

This runs `bun build` on `client/main.ts` (bundling Three.js and all client code into `dist/main.js`) and copies `client/index.html` to `dist/index.html`. The server then serves everything from `dist/`.

---

## Project Layout

```
swarm-viz/
├── client/
│   ├── index.html       # Shell HTML with HUD elements
│   ├── main.ts          # Entry: WebSocket + scene wiring
│   ├── scene.ts         # Three.js scene, force layout, animations
│   └── websocket.ts     # Reconnecting WebSocket client
├── server/
│   ├── index.ts         # Bun server: SQLite polling, WebSocket push
│   └── mappers.ts       # DB row → protocol type transformations
├── shared/
│   └── types.ts         # Protocol types shared between server and client
├── dist/                # Built client (generated by bun run build)
└── package.json
```

---

## WebSocket Protocol

On connect the server sends a full **snapshot**. Subsequent messages are incremental **updates** at `POLL_INTERVAL_MS` intervals.

```typescript
// Initial connection
{ type: "snapshot", data: StateSnapshot }

// Incremental updates
{ type: "update", data: StateUpdate }

// StateUpdate is one of:
{ type: "agent_update",   data: Agent }
{ type: "message_event",  data: AgentMessage }
{ type: "merge_update",   data: MergeQueueEntry }
{ type: "metrics_update", data: SwarmMetrics }
```

Client → server messages are not used; the visualization is read-only.

---

## Overstory Integration

swarm-viz is a passive observer of [Overstory](https://github.com/jayminwest/overstory), the multi-agent swarm coordination framework. Overstory manages agent lifecycles, task dispatch, mail routing, and merge pipelines. swarm-viz reads the same SQLite state files Overstory writes and renders them visually.

This project itself was built by an Overstory swarm — 21 agents across multiple sessions coordinated to produce the initial implementation. The architecture reflects patterns from the [Agentic Engineering Book](https://github.com/jayminwest/agentic-engineering-book): parallel builder agents working in isolated worktrees, a merge pipeline for integration, and real-time observability as a first-class concern.

---

## Development

```bash
bun run typecheck   # TypeScript type check (no emit)
bun run lint        # Biome lint + format check on client/
bun test            # Run tests
```

See [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) for a deep-dive into the data flow and component design.
